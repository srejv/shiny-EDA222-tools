Just a small project for designing real time applications in TinyTimer.

So this is basically a small design document and proposal or something. :)

It's a HTML5, js, CSS, SVG, WebApp for generating TinyTimber compilable C-code (for my own use on HC12 for our labs, but any TinyTimber application is supposed to be possible).

js libraries: 

	* jQuery.js
	* underscore.js
	* jQuery.poshytip.js
	* jsjoint.js
	* jQuery-editable.js

templating: 

	* handlebars

Im in the search for some syntax prettifier.

ScriptEditor todo:

	* Generate test file for WCET.
	* Load Generated application.c
	* Design
	* Structure it better (paper plans)

Flow Editor todo: 

	* Implement new node structure
	* Load data structure
	* Auto-add links
	* Auto-positioning

Timeline generation todo:
	* Everything. Hardly even started but I have the structure and design on paper. :)

Would like to use: D3.js, Tangle.js or something else for visualization and Reactive Documents. (So me and my partner can write our report and have cool reactive support and explanations. would be pretty sweet.)

Script Editor:

  - Creqte and Edit your objects (State Machines)
  - Add methods
  - Add global variables
  - Add functions
  - Add your interrupts, and set up their callbacks
  - Add your include-files
  - Edit the kickoff function, so you can set it up however you want.
  - And of course editable (Body of functions and methods, names, intial values...)
  - Generate application.c, compilable, indented C-code (just the indentation part left)
  - Generate application-test-all-methods-for-WCET.c, compilable, indented C-code (TODO: should be pretty straightforward)
  - Load a generated application.c file, and turn into the internal datastructure for emulation. (TODO ;))

Flow Editor:

  - Get a node graph over your code
  - All calls and connections are shown as nodes and links. 
  - See the spaghetti you've created. 
  - Loops look funny. 
  - Some primitives
  	* NodeTemplate
  		+ inPort: [Begin] // With possible variable passing
  			Desc: Values are passed into the inPorts from:
  				+ Global variables in the graph
  				+ Function return statements
  			When a value is passed to the inport of a node, it's variablePort linked nodes are executed, and after that the links from the outports are called. 
  		+ outPort: [After] // To be called after.. kind of.
  			Desc: What will be called after the result of this
  			Used by call nodes to signify next node to execute.
  			Methods are usually called from different type of scheduling nodes, and they are usually connected from this port on those nodes. 
  		+ variablePort: [Inside] 
  			Desc: When the node is entered during playback, the body's Call nodes are called, these are the function bodies that contain the data processing of the node. After that the different ASYNC calls are made. 
  	* Method (inPuts: object, (int) | outputs: (int))
  		- Body
  			+ [Calls]
  		- [Async]
  		- [After]
  		- [Before]
  		- [Send]
  	* Call
  		- IF
  		- FOR
  		- WHILE -> Contains [  ]
  		- variable | expression
  			+ Examples:
  			+ variable: int x, expression: 
  			+ variable: CANMsg msg
  			+ expression: SCI_INIT(&sci0)
  			+ expression: CAN_INIT(&can0)
  			+ expression: SCI_WRITE(&sci0, "Hello hello...\n");
  			+ variable: msg.msgId, expression: 1
  			+ variable: msg.nodeId, expression: 1
  			+ variable: msg.length, expression: 6
			+ variable: msg.buff[0], expression: 'H'
			+ variable: msg.buff[1], expression: 'e'
			+ variable: msg.buff[2], expression: 'l'
			+ variable: msg.buff[3], expression: 'l'
			+ variable: msg.buff[4], expression: 'o'
			+ variable: msg.buff[5], expression: 0
			+ expression: CAN_SEND(&can0, &msg)
			+ variable: p->ddrp, expression: 0x1
			+ expression: ASYNC(self,tone, 0)  // Would be turned into an ASYNC node
			+ expression: ASYNC(self,loadLoop, 0) // Would be turned into an ASYNC node
  	* Variable
  		- Type, Name, Value
  	* State Machines : Variable
  		- The global state machines from the code, for plugging into the methods
  	* Function  : Method (any args)
  - Editable

Timeline Playback:

  - Dispatcher algorithm
  	+ Choose your dispatcher algorithms (TODO)
  - Timeline
  	+ Get a timeline over the events and timing calls!
  	+ Not the real time thing, but as close as possible... using WCET.
  - Deadlines
  	+ Deadlines generated by the code & editors are shown
  	+ Gets very visible when missed
  - Delays
  	+ Delays to show the new baseline offsets 
  	+ Used to show when a function has its earliest possible call when considering the scheduling algorithm. Or something... it should be clear from the timeline.
  - Execution 
  	+ Show when the application would be calling the methods, who blocks who when and all that important and interesting stuff. 
  	+ Execution is based on WCET and the Interrupt Vector (which are of course editable.)
  - Using WCET
  	+ Use the generated values from the appication.c tests (have to be run and entered manually, but it's pretty streamlined ;) its hard to do those things in js (not really if I would use node.js as backend, but I don't know if the compiler, flash eraser and uploader are callable from the command line. I should guess that they are though. Might be added to the todo list if I or YOU feel like it. ;)), 
  - Interrupt Vector
  	+ Create an interrupt vector for testing what happens when interrupts are called during normal execution
  - Generate graphs for the paper
  	+ Generate all the timing charts and graphs for the paper. Maybe generate a reactive document that uses LaTeX and adds option to edit the variables on the timeline in real time instead of just reading about it on paper? very possible, but would it be an acceptable hand-in?)

